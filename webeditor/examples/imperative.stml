
# value_restriction = true

val (+) : (int, int) -> int
val (-) : (int, int) -> int
val ( * ) : (int, int) -> int
val (/) : (int, int) -> int
val (%) : (int, int) -> int

val (<) : (int, int) -> bool
val (<=) : (int, int) -> bool
val (>) : (int, int) -> bool
val (>=) : (int, int) -> bool

abstract type ref('a)
val ref : 'a -> ref('a)
val (<-) : (ref('a), 'a) -> ()
val (!) : ref('a) -> 'a

val ref_42 : ref(int)
let ref_42 = ref 42
let mutate_ref x =
  let y = ref x in
  y <- 42 ; !y

abstract type dict('k, 'v)
abstract type array('a)

val dict : () -> dict('a, 'b)
val array : () -> array('a)
val ([]<-) : ((dict('a, 'b), 'a, 'b) -> ()) & ((array('b), int, 'b) -> ())
val ([]) : ((dict('a, 'b), 'a) -> 'b) & ((array('b), int) -> 'b)
val push : array('a) -> 'a -> ()
val len : array('a) -> int

let test_dict x =
  let d = dict () in
  d[x]<- 42 ;
  d["key"]<- 0 ;
  d, d[false]

let filter_arr (f:('a -> any) & ('b -> ~true)) (arr:array('a|'b)) =
  let res = array () in
  let i = ref 0 in
  while !i < (len arr) do
    let e = arr[!i] in
    if f e do push res e end ;
    i <- (!i + 1)
  end ;
  res

val test_arr : 'a -> array('a | 'b)
let test_arr x =
  let arr = array () in
  push arr true ;
  push arr x ;
  push arr false ;
  filter_arr (fun x -> if x is int then true else false) arr

let nested x y =
  let d = dict () in
  d[x]<- (array ()) ;
  (d[x])[0]<- y ; (d[x])[0]

val swap : ('a -> 'a -> dict('a,'b) -> ())
         & (int -> int -> array('b) -> ())
let swap i j x =
    let tmp = x[i] in
    x[i]<- x[j] ; x[j]<- tmp

let rec_and_imp arr k i n =
  if k < n do arr[k]<- (i+k) ; rec_and_imp arr (k+1) i n end

let interval i j =
  let arr = array () in
  rec_and_imp arr 0 i ((j-i)+1) ; arr